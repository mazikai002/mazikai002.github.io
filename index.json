[{"categories":null,"content":"索引失效","date":"2022-08-17","objectID":"/mysql-index_failure/","tags":["mysql"],"title":"MySQL 优化手段 —— 索引失效","uri":"/mysql-index_failure/"},{"categories":null,"content":" 聊聊索引失效 总结 模 : 模糊查询。like查询以%开头，会导致索引失效。可以有两种方式优化(覆盖索引、最左匹配) 数 : 数据类型。编写SQL时要保证索引字段与匹配数据类型一致。 函 : 数据处理。索引字段不做函数处理。 空 : null值。唯一索引有null值。 运 : 运算。索引字段不做运算。 左 : 最左匹配原则。 回 : 回表超过临界值，避免回表尽量覆盖索引。 参考 https://bbs.huaweicloud.com/blogs/333163 ","date":"2022-08-17","objectID":"/mysql-index_failure/:0:0","tags":["mysql"],"title":"MySQL 优化手段 —— 索引失效","uri":"/mysql-index_failure/"},{"categories":null,"content":"分库分表","date":"2022-06-30","objectID":"/mysql-separate_librarytable/","tags":["mysql"],"title":"MySQL 优化手段 —— 分库分表","uri":"/mysql-separate_librarytable/"},{"categories":null,"content":" 分库分表 切分目的 当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的是为了减少数据库的负担，缩短查询的时间。 ","date":"2022-06-30","objectID":"/mysql-separate_librarytable/:0:0","tags":["mysql"],"title":"MySQL 优化手段 —— 分库分表","uri":"/mysql-separate_librarytable/"},{"categories":null,"content":"表垂直拆分 优点：列数据变小，数据页可以存放更多数据，在查询时减少I/O次数 缺点：主键冗余、连表操作（JOIN）、行数据大 ","date":"2022-06-30","objectID":"/mysql-separate_librarytable/:0:1","tags":["mysql"],"title":"MySQL 优化手段 —— 分库分表","uri":"/mysql-separate_librarytable/"},{"categories":null,"content":"表水平拆分 优点：行数据变小；切分出的表结构相同，程序改动小 缺点：连表操作（JOIN）、分片事务一致性难以解决 参考 https://zhuanlan.zhihu.com/p/375951738 ","date":"2022-06-30","objectID":"/mysql-separate_librarytable/:0:2","tags":["mysql"],"title":"MySQL 优化手段 —— 分库分表","uri":"/mysql-separate_librarytable/"},{"categories":null,"content":"浅谈Context","date":"2022-05-22","objectID":"/go-context/","tags":["golang"],"title":"Golang 基本语法 —— 浅谈 Context","uri":"/go-context/"},{"categories":null,"content":" context为Go中的一个标准库, 专门用来处理多个协程之间的控制问题, 比如协程的取消, 协程运行截止时间, 协程运行的超时时间, 协程之间的数据传输等. context使用规则 context要作为函数的第一个参数使用, 不要试图将它放入结构体中 当方法或函数需要一个context时, 不要传入nil, 可以传入context.TODO context可以传入到不同的协程中,** 并且在多个协程中是安全的** 当context传入到子协程中时, 需要在子协程中监控conext.Done()返回的通道, 当收到通知时, 停止当前子协程的运行, 释放资源并返回到上层 并发安全？ func main() { ctx := context.WithValue(context.Background(), \"asong\", \"test01\") go func() { for { _ = context.WithValue(ctx, \"asong\", \"test02\") } }() go func() { for { _ = context.WithValue(ctx, \"asong\", \"test03\") } }() go func() { for { fmt.Println(ctx.Value(\"asong\")) } }() go func() { for { fmt.Println(ctx.Value(\"asong\")) } }() time.Sleep(10 * time.Second) } context添加的键值对一个链式的，会不断衍生新的context，所以context本身是不可变的**，因此是线程安全的。** !https://secure2.wostatic.cn/static/uSBmnegpS63aHSVxPCKCkq/image.png?auth_key=1709437657-jBqxaGan91qXdknbrRbeKZ-0-fb5050a3090ee6e8b1e7750c44241b3c ","date":"2022-05-22","objectID":"/go-context/:0:0","tags":["golang"],"title":"Golang 基本语法 —— 浅谈 Context","uri":"/go-context/"},{"categories":null,"content":"Context包 父子关系 控制是从上至下的，查找是从下至上的。 context 的实例之间存在父子关系： 当父亲取消或者超时，所有派生的子context 都被取消或者超时 找 key 的时候，子 context 先看自己有没有，没有则去祖先里面找控制是从上至下的，查找是从下至上的。 父context是无法拿到子context的key的值得，只能看到自己的 context.WithCancel的使用 withcancel 使用demo，我理解就是当前线程用来控制子协程退出的工具 package main import ( \"context\" \"fmt\" \"time\" ) func slowfunc1(ctx context.Context) { defer func() { fmt.Println(\"end slowfunc1\") }() fmt.Println(\"start slowfunc1\") for { select { case \u003c-ctx.Done(): fmt.Println(\"slowfunc1 end by main\") return default: } } } func slowfunc(ctx context.Context) { defer func() { fmt.Println(\"end slowfunc\") }() fmt.Println(\"start slowfunc\") go slowfunc1(ctx) for { select { case \u003c-ctx.Done(): fmt.Println(\"slowfunc end by main\") return default: } } } func main() { fmt.Println(\"start main \") ctx := context.Background() ctxWithCancel, cancelfunc := context.WithCancel(ctx) defer func() { //cancelfunc() time.Sleep(2 * time.Second) // 不等待的话子线程来不及打印，但是会退出 fmt.Println(\"end main\") // cancelfunc() }() go slowfunc(ctxWithCancel) time.Sleep(3 * time.Second) cancelfunc() } context.WithValue的使用 func valueFunc() { // 使用context.WithValue创建一个conext // 设置要通过context要传递的键值 ctx := context.WithValue(context.Background(), \"key\", \"value\") go valueFunc2(ctx) time.Sleep(time.Second) } func valueFunc2(ctx context.Context) { // 通过context提供的Value方法来获取数据 v := ctx.Value(\"key\") fmt.Println(\"value: \", v) } 参考 https://juejin.cn/post/7001273893780471845 ","date":"2022-05-22","objectID":"/go-context/:1:0","tags":["golang"],"title":"Golang 基本语法 —— 浅谈 Context","uri":"/go-context/"},{"categories":null,"content":"struct可以比较吗","date":"2022-03-18","objectID":"/go-struct/","tags":["golang"],"title":"Golang 基本语法 —— struct可以比较吗","uri":"/go-struct/"},{"categories":null,"content":" struct能不能比较？得分情况！ struct能不能比较？ 很显然这句话包含了两种情况： 同一个struct的两个实例能不能比较？ 两个不同的struct的实例能不能比较？ 在分析上面两个问题前，先梳理一下golang中，哪些数据类型是可比较的，哪些是不可比较的： 可比较：Integer，Floating-point，String，Boolean，Complex(复数型)，Pointer，Channel，Interface，Array 不可比较：Slice，Map，Function 同一个struct 同一个struct的两个实例可比较也不可比较，当结构不包含不可直接比较成员变量时可直接比较，否则不可直接比较 type S struct { Name string Age int Address *int } func main() { a := S{ Name: \"aa\", Age: 1, Address: new(int), } b := S{ Name: \"aa\", Age: 1, Address: new(int), } fmt.Println(a == b) } 这段代码会输出false 因为上面的结构体不包含不可比较的成员变量，所以是可以比较的 type S struct { Name string Age int Address *int Data []int } func main() { a := S{ Name: \"aa\", Age: 1, Address: new(int), Data: []int{1, 2, 3}, } b := S{ Name: \"aa\", Age: 1, Address: new(int), Data: []int{1, 2, 3}, } fmt.Println(a == b) } 这段代码的输出是：./prog.go:28:14: invalid operation: a == b (struct containing []int cannot be compared) 因为结构体包含了不可比较的成员变量slice，导致代码编译不通过 reflect.DeepEqual 用来对含有不可直接比较的数据类型的结构体实例进行比较 type S struct { Name string Age int Address *int Data []int } func main() { a := S{ Name: \"aa\", Age: 1, Address: new(int), Data: []int{1, 2, 3}, } b := S{ Name: \"aa\", Age: 1, Address: new(int), Data: []int{1, 2, 3}, } fmt.Println(reflect.DeepEqual(a, b)) } 这段代码返回true DeepEqual函数用来判断两个值是否深度一致。具体比较规则如下： 不同类型的值永远不会深度相等 当两个数组的元素对应深度相等时，两个数组深度相等 当两个相同结构体的所有字段对应深度相等的时候，两个结构体深度相等 当两个函数都为nil时，两个函数深度相等，其他情况不相等（相同函数也不相等） 当两个interface的真实值深度相等时，两个interface深度相等 map的比较需要同时满足以下几个 两个map都为nil或者都不为nil，并且长度要相等 相同的map对象或者所有key要对应相同 map对应的value也要深度相等 指针，满足以下其一即是深度相等 两个指针满足go的==操作符 两个指针指向的值是深度相等的 切片，需要同时满足以下几点才是深度相等 两个切片都为nil或者都不为nil，并且长度要相等 两个切片底层数据指向的第一个位置要相同或者底层的元素要深度相等 注意：空的切片跟nil切片是不深度相等的 其他类型的值（numbers, bools, strings, channels）如果满足go的==操作符，则是深度相等的。要注意不是所有的值都深度相等于自己，例如函数，以及嵌套包含这些值的结构体，数组等 不同的struct 可以比较，也不可以比较，不含有不可比较类型的时候可以通过强转来比较。 type T2 struct { Name string Age int Arr [2]bool ptr *int } type T3 struct { Name string Age int Arr [2]bool ptr *int } func main() { var ss1 T2 var ss2 T3 // Cannot use 'ss2' (type T3) as type T2 in assignment //ss1 = ss2 // 不同结构体之间是不可以赋值的 ss3 := T2(ss2) fmt.Println(ss3==ss1) // true } 这段代码返回true 但是当结构体包含不可比较的成员变量时候，强转比较也会报错 type T2 struct { Name string Age int Arr [2]bool ptr *int map1 map[string]string } type T3 struct { Name string Age int Arr [2]bool ptr *int map1 map[string]string } func main() { var ss1 T2 var ss2 T3 ss3 := T2(ss2) fmt.Println(ss3==ss1) // 含有不可比较成员变量 } ./prog.go:28:14: invalid operation: ss3 == ss1 (struct containing map[string]string cannot be compared) 含有不能比较的结构体互转后可以使用deepequal比较 import ( \"fmt\" \"reflect\" ) type T2 struct { Name string Age int Arr [2]bool ptr *int map1 map[string]string } type T3 struct { Name string Age int Arr [2]bool ptr *int map1 map[string]string } func main() { var ss1 T2 var ss2 T3 ss3 := T2(ss2) fmt.Println(reflect.DeepEqual(ss3, ss1)) // 含有不可比较成员变量 } 这段代码返回true 问：struct可以作为map的key么 struct必须是可比较的，才能作为key，否则编译时报错 type T1 struct { Name string Age int Arr [2]bool ptr *int slice []int map1 map[string]string } type T2 struct { Name string Age int Arr [2]bool ptr *int } func main() { // n := make(map[T2]string, 0) // 无报错 // fmt.Print(n) // map[] m := make(map[T1]string, 0) fmt.Println(m) // invalid map key type T1 } 参考 https://www.jianshu.com/p/5641648664d8 ","date":"2022-03-18","objectID":"/go-struct/:0:0","tags":["golang"],"title":"Golang 基本语法 —— struct可以比较吗","uri":"/go-struct/"},{"categories":null,"content":"make和new是内置函数，不是关键字，var是关键字","date":"2022-01-21","objectID":"/go-diff_of_stringbyte/","tags":["golang"],"title":"Golang 基本语法 —— []byte和string的不同","uri":"/go-diff_of_stringbyte/"},{"categories":null,"content":" []byte和string的不同 为啥string和[]byte类型转换需要一定的代价？ 为啥内置函数copy会有一种特殊情况copy(dst []byte, src string) int? string和[]byte，底层都是数组，但为什么[]byte比string灵活，拼接性能也更高（动态字符串拼接性能对比）? 何为string？ 什么是字符串？标准库builtin的解释： type string string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable. 简单的来说字符串是一系列8位字节的集合，通常但不一定代表UTF-8编码的文本。字符串可以为空，但不能为nil。而且字符串的值是不能改变的。不同的语言字符串有不同的实现，在go的源码中src/runtime/string.go，string的定义如下： type stringStruct struct { str unsafe.Pointer len int } 可以看到str其实是个指针，指向某个数组的首地址，另一个字段是len长度。那到这个数组是什么呢？ 在实例化这个stringStruct的时候： func gostringnocopy(str *byte) string { ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} s := *(*string)(unsafe.Pointer(\u0026ss)) return s } 哈哈，其实就是byte数组，而且要注意string其实就是个struct。 何为[]byte? 首先在go里面，byte是uint8的别名。而slice结构在go的源码中src/runtime/slice.go定义： type slice struct { array unsafe.Pointer len int cap int } array是数组的指针，len表示长度，cap表示容量。除了cap，其他看起来和string的结构很像。 但其实他们差别真的很大。 区别 字符串的值是不能改变 在前面说到了字符串的值是不能改变的，这句话其实不完整，应该说字符串的值不能被更改，但可以被替换。 还是以string的结构体来解释吧，所有的string在底层都是这样的一个结构体stringStruct{str: str_point, len: str_len}，string结构体的str指针指向的是一个字符常量的地址， 这个地址里面的内容是不可以被改变的，因为它是只读的，但是这个指针可以指向不同的地址，我们来对比一下string、[]byte类型重新赋值的区别： s := “A1” // 分配存储\"A1\"的内存空间，s结构体里的str指针指向这快内存 s = “A2” // 重新给\"A2\"的分配内存空间，s结构体里的str指针指向这快内存 其实[]byte和string的差别是更改变量的时候array的内容可以被更改。 s := []byte{1} // 分配存储1数组的内存空间，s结构体的array指针指向这个数组。 s = []byte{2} // 将array的内容改为2 因为string的指针指向的内容是不可以更改的，所以每更改一次字符串，就得重新分配一次内存，之前分配空间的还得由gc回收，这是导致string操作低效的根本原因。 string和[]byte的相互转换 将string转为[]byte，语法[]byte(string)源码如下： func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s) \u003c= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b } func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026s).str = p stringStructOf(\u0026s).len = size *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, size} return } 可以看到b是新分配的，然后再将s复制给b，至于为啥copy函数可以直接把string复制给[]byte，那是因为go源码单独实现了一个slicestringcopy函数来实现，具体可以看src/runtime/slice.go。 将[]byte转为string，语法string([]byte)源码如下： func slicebytetostring(buf *tmpBuf, b []byte) string { l := len(b) if l == 0 { // Turns out to be a relatively common case. // Consider that you want to parse out data between parens in \"foo()bar\", // you find the indices and convert the subslice to string. return \"\" } if raceenabled \u0026\u0026 l \u003e 0 { racereadrangepc(unsafe.Pointer(\u0026b[0]), uintptr(l), getcallerpc(unsafe.Pointer(\u0026buf)), funcPC(slicebytetostring)) } if msanenabled \u0026\u0026 l \u003e 0 { msanread(unsafe.Pointer(\u0026b[0]), uintptr(l)) } s, c := rawstringtmp(buf, l) copy(c, b) return s } func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { if buf != nil \u0026\u0026 l \u003c= len(buf) { b = buf[:l] s = slicebytetostringtmp(b) } else { s, b = rawstring(l) } return } 依然可以看到s是新分配的，然后再将b复制给s。 正因为string和[]byte相互转换都会有新的内存分配，才导致其代价不小，但读者千万不要误会，对于现在的机器来说这些代价其实不值一提。 但如果想要频繁string和[]byte相互转换（仅假设），又不会有新的内存分配，能有办法吗？答案是有的。 package string_slicebyte_test import ( \"log\" \"reflect\" \"testing\" \"unsafe\" ) func stringtoslicebyte(s string) []byte { sh := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) bh := reflect.SliceHeader{ Data: sh.Data, Len: sh.Len, Cap: sh.Len, } return *(*[]byte)(unsafe.Pointer(\u0026bh)) } func slicebytetostring(b []byte) string { bh := (*reflect.SliceHeader)(unsafe.Pointer(\u0026b)) sh := reflect.StringHeader{ Data: bh.Data, Len: bh.Len, } return *(*string)(unsafe.Pointer(\u0026sh)) } func TestStringSliceByte(t *testing.T) { s1 := \"abc\" b1 := []byte(\"def\") copy(b1, s1) log.Println(s1, b1) s := \"hello\" b2 := stringtoslicebyte(s) log.Println(b2) // b2[0] = byte(99) unexpected fault address b3 := []byte(\"test\") s3 := slicebytetostring(b3) log.Println(s3) } 答案虽然有，但强烈推荐不要使用这种方法来转换类型，因为如果通过stringtoslicebyte将string转为[]byte的时候，共用的时同一块内存，原先的string内存区域是只读的，一但更改将会导致整个进程down掉，而且这个错误是runtime没法恢复的。 如何取舍？ 既然string就是一系列字节，而[]byte也可以表达一系列字节，那么实际运用中应当如何取舍？ string可以直接比较，而[]by","date":"2022-01-21","objectID":"/go-diff_of_stringbyte/:0:0","tags":["golang"],"title":"Golang 基本语法 —— []byte和string的不同","uri":"/go-diff_of_stringbyte/"},{"categories":null,"content":"make和new是内置函数，不是关键字，var是关键字","date":"2021-12-17","objectID":"/go-diff_of_newmake/","tags":["golang"],"title":"Golang 基本语法 —— var、new、make区别及使用","uri":"/go-diff_of_newmake/"},{"categories":null,"content":" make和new是内置函数，不是关键字，var是关键字 一：对于值类型的变量，我们通过var 声明(包括结构体)，系统会默认为他分配内存空间，并赋该类型的零值。如下，我们声明一个int类型变量i，输出为0。 var i int fmt.Println(i) //i=0 而如果我们声明一个指针类型的变量，系统不会为他分配内存(应该是不会为这个指针分配一个内存给他指向)，默认就是nil。此时如果你想直接使用，那么系统会抛异常。 var j *int fmt.Println(j) //nil类型，因为指针的0值就是nil fmt.Println(\u0026j) //0xc00000e028 这是指针变量的地址 fmt.Println(*j) //因为这个指针没有指向任何内存,报错 *j = 10 //invalid memory address or nil pointer dereference， 空指针还没指向任何内存，是不能使用的。 二：那么要想使用，此时就需要new出场啦。 var j *int j = new(int) // j里面的内容指向一块分配好的内存地址，地址里面设置int的零值：0 fmt.Println(j) // 0xc000018040 fmt.Println(*j) //0 *j = 10 fmt.Println(*j) 声明指针类型变量后，通过new为他分配指向的内存，有了内存空间，这个变量就可以自由的使用了。 来看一下new函数的签名： 它只接受一个参数，这个参数是一个类型，**分配好内存后，返回一个指向该类型内存地址的指针。这块内存上存的是类型的零值。**这个类型也能是指针。 package main import ( \"fmt\" ) func main(){ a := new(*int) fmt.Println(a) fmt.Println(*a) *a = new(int) fmt.Println(*a) fmt.Println(**a) } 0xc0000b2018 \u003cnil\u003e 0xc0000b8010 0 *但是，**实际在工程使用中，通常是直接声明指针使用，不需要new操作。 三：make和new不同，make用于map, slice,chan 的内存创建，因为他们三个是引用类型，直接返回这三个类型本身。make签名是： func make(t Type, size ...IntegerType) Type make 是分配内存并初始化，初始化并不是置为零值。 与new一样，它的第一个参数也是一个类型，但是不一样的是，make返回的是传入的类型，而不是指针！ var c chan int //声明管道类型变量c，此时c还是nil，不可用； fmt.Printf(\"%#v \\\\n\",c) //(chan int)(nil) c = make(chan int) fmt.Printf(\"%#v\", c) //(chan int)(0xc000062060) 声明管道类型变量c，此时c还是nil，不可用； 通过make来分配内存并初始化，c就获得了内存可以使用了。 所以，我们在使用map, slice,chan 的时候，需要先对他们用make初始化，然后在进行操作。 总结： var 分配内存，赋0值，返回类型 new 分配内存，赋0值，返回类型指针（指向刚才分配内存的指针） make给map，channel，slice分配内存，不赋0值，返回类型 Var指针类型一般是var+new；Var三种引用类型时候，一般是var+make make和new的区别 new 和 make都是用来创建和分配内存的，可能在栈上，也可能在堆上，是内存逃逸分析后确定创建在哪里的。 new 返回的是指针，指向新分配的类型的零值；make 返回的是值，这个值已经被初始化（例如，一个新的切片，它的元素已经被分配了内存）。 new 可以用于任何类型，而 make 只能用于切片、映射和通道。 make 创建的切片、映射或通道已经准备好使用，而 new 创建的值需要进一步初始化。 为什么要给三种引用类型单独实现一个make 函数？ 这是因为slice, map和chan的底层结构上要求在使用slice，map和chan的时候必须初始化，如果不初始化，那slice，map和chan的值就是零值，也就是nil。我们知道： map如果是nil，是不能往map插入元素的，插入元素会引发panic chan如果是nil，往chan发送数据或者从chan接收数据都会阻塞 slice会有点特殊，理论上slice如果是nil，也是没法用的。但是append函数处理了nil slice的情况，可以调用append函数对nil slice做扩容。但是我们使用slice，总是会希望可以自定义长度或者容量，这个时候就需要用到make。 那么，可以使用new来初始化引用类型吗？可以的！ 参考 https://huweicai.com/ https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/ https://blog.wu-boy.com/2021/06/what-is-different-between-new-and-make-in-golang/ https://fivezh.github.io/2020/03/15/golang-new-make/ ","date":"2021-12-17","objectID":"/go-diff_of_newmake/:0:0","tags":["golang"],"title":"Golang 基本语法 —— var、new、make区别及使用","uri":"/go-diff_of_newmake/"},{"categories":null,"content":" 博客的意义在于自己梳理知识，总结经验，顺便和他人进行技术交流。 这是我的第一篇博客，记录我是如何搭建这个网站的！希望对您也有帮助~ ","date":"2021-11-06","objectID":"/blog-setup/:0:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"所需工具 ","date":"2021-11-06","objectID":"/blog-setup/:1:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"Hugo + GitHub Pages + GitHub Actions + DomainRegistration ","date":"2021-11-06","objectID":"/blog-setup/:1:1","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"1 概念 ","date":"2021-11-06","objectID":"/blog-setup/:2:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"1.1 什么是 Hugo？ Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator）。可以把 Markdown 文件转化成 HTML 文件。 ","date":"2021-11-06","objectID":"/blog-setup/:2:1","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"1.2 什么是 GitHub Pages？ GitHub Pages 是一组静态网页集合（Static Web Page），这些静态网页 HTML 文件由 GitHub 托管（host）和发布，所以是 GitHub + Pages。 ","date":"2021-11-06","objectID":"/blog-setup/:2:2","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"1.3 Github Action Hugo 都是静态博客，即最终生成的是静态页面，而所谓部署就是把这些静态文件放到 web 服务器(比如 Nginx、Caddy) 的对应目录就行了。 因此整个 Github Action 只需要做两件事： 1）编译，生成静态文件 2）部署，把静态文件移动到合适的位置 - 比如放到某个云服务器上 - 或者放到 Github Pages 然后我们再通过 git push 来触发 Github Action 就可以了。 ","date":"2021-11-06","objectID":"/blog-setup/:2:3","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"2 过程 ","date":"2021-11-06","objectID":"/blog-setup/:3:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"2.1 配置Hugo 2.1.1 安装Hugo 这里使用包管理器安装 Hugo，我的操作系统是 Mac OS，所以使用 Homebrew 安装 Hugo。如果你使用的是 Windows 或 Linux，可以根据 Hugo 文档提示的方式安装： Hugo 文档：Install Hugo brew install hugo # 查看 Hugo 是否安装成功，显示 Hugo 版本号代表 Hugo 安装成功。 hugo version 2.1.2 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了。 hugo new site Blog 2.1.3 配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。下面我就以我目前在使用的 LoveIt 这个主题为例，演示一下配置流程。 我们可以将主题仓库直接 git clone 下来进行使用，但这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。我采用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。 cd blog-test/ git init git submodule add https://github.com/pseudoyu/LoveIt themes/LoveIt 每个主题一般都会提供一些实例配置与初始页面，开始使用主题时可以将其 exampleSite/ 目录下的文件复制到站点目录下，在此基础上进行调整配置。 cp -rf themes/LoveIt/exampleSite/* ./ 初始化主题基础配置后，我们可以在 config.toml 文件中进行站点细节配置，具体配置项参考各主题说明文档。 2.1.4 发布文章 完成后，可以通过 hugo new 命令发布新文章。 hugo new posts/blog-test.md 2.1.5 本地调试 Hugo 会生成静态网页，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。 hugo server 运行服务后，我们可以通过浏览器 http://localhost:1313 地址访问我们的本地预览网页。 ","date":"2021-11-06","objectID":"/blog-setup/:3:1","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"2.2 创建GitHub仓库 命名博客源仓库（username.github.io） 勾选 Public，设置为公开仓库。 勾选添加 README 文件 ","date":"2021-11-06","objectID":"/blog-setup/:3:2","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"2.3 创建GitHub Page 在博客源仓库下创建GitHub Pages（Settings-\u003ePages） ","date":"2021-11-06","objectID":"/blog-setup/:3:3","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"2.4 创建GitHub Actions 需要在仓库根目录下创建 .github/workflows 这个二级目录，然后在 workflows 下以 .yml 形式配置 Github Action。 name:publish to gh-pages# 流水线名称on:# on 表示 GitHub Action 触发条件push:branches:- main# main分支env:REGISTRY:ghcr.ioIMAGE_NAME:${{ github.repository }}jobs:# jobs 表示 GitHub Action 中的任务build:runs-on:ubuntu-latest# runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。# permissions:# contents: read# packages: writeconcurrency:group:${{ github.workflow }}-${{ github.ref }}steps:- name:checkout# 检查uses:actions/checkout@v2# uses 中的为 GitHub Action 中的一个插件with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:setup hugo# 安装uses:peaceiris/actions-hugo@v2 with:hugo-version:'0.105.0'# hugo的版本号extended:true- name:build web# 构建run:hugo --minify- name:deploy web# 部署uses:peaceiris/actions-gh-pages@v3if:${{ github.ref == 'refs/heads/main' }}with:github_token:${{ secrets.GH_PAGE_ACTION_TOKEN }}publish_dir:./publiccname:mazikai002.cn# 重点 ！！！个人域名使用# PUBLISH_BRANCH: gh-pages，peaceiris/actions-gh-pages@v3插件默认指定生成分支 整个 Action 一个包含 4 个步骤： 1）拉取代码 2）准备 hugo 环境 3）使用 hugo 编译生成静态文件 4）把生成的静态文件发布到 Github Pages 以上需要特别注意的是 Hugo 的版本以及是否启用 hugo 扩展。 因为我们需要从仓库的main分支推送到仓库的gh-pages分支，这需要特定权限，故要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。 权限需要开启admin:org(read write)、repo、workflow三块权限。 配置后复制生成的 Token（注：只会出现一次），然后在我们博客源仓库的 Settings - Secrets and variables - Actions - Environment secrets 中添加 GITHUB_TOKEN 环境变量为刚才的 Token，这样 GitHub Action 就可以获取到 Token 了。 同时 Settings - Actions - General的最下方的一个选项选择Read and write permissions 完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。 ","date":"2021-11-06","objectID":"/blog-setup/:3:4","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"2.5 博客绑定域名 2.5.1 创建 CNAME 首先在你的库下面添加一个 CNAME （别名记录）文件，建议直接在 GitHub 那创建!(这一步在workflows的yml文件中最后一行已经配置)，参考你的域名进行编写。 2.5.2 添加 DNS 解析 然后是添加解析，我域名是在腾讯云买的，所以直接在腾讯云那添加解析了。 我添加的解析如下,供参考，记得把 username 改成你自己的。 @ A 185.199.109.153 @ A 185.199.110.153 www CNAME username.github.io. A 记录的 ip 地址可以在下面中选择 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 2.5.3 修改设置 添加完成后进入库的设置，找到 GitHub Pages ，如果能看到类似 Your site is published at https://mazikai002.cn/ 这样的文字，说明就搞定了。 Enforce HTTPS 最好勾选上，GitHub 提供的这个可以直接让你的网站从 HTTP 升级到 HTTPS，非常赞。 ","date":"2021-11-06","objectID":"/blog-setup/:3:5","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"3 流程 使用hugo创建个人站点，hugo new site，hugo new post… git commit 提交 触发 github action .github/workflows/my-pipeline.yml 并满足设置中的 on 条件 触发 pipeline 中的 steps checkout：相当与 git clone，并且后续操作具有 github 完整权限，可以通过 permissions 设置 setup hugo：准备构建要求，安装对应版本，注意是否需要 extended build：构建出静态文件，并输出到 public 文件夹 deploy：该插件来自 插件市场 自动创建分支 gh-pages 自动 copy public 到新分支 自动提交 自动生成 CNAME 文件，根据 cname 设置，想要 自定义域名 的注意这里了 打开 https://github.com/{你的名字}/{你的仓库}/settings/pages（后续步骤只需要一次） Source 选择 gh-pages ，文件夹: 默认 / (root) ，并 save 注意上方提示 Your site is ready to be published at https://xxx.github.io/xxx/ 将域名部分做 解析 Custom domain 设置 自己的域名 Enforce HTTPS 点一下，然后等一会 ","date":"2021-11-06","objectID":"/blog-setup/:4:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"4 总结 可以将主题下相关文件复制到 blog 网站根目录下，因为这样可以直接渲染网站效果，而又不影响主题本身的内容。 主要是 themes\\LoveIt\\exampleSite 目录下文件。 发布文章如果有参数 draft ，记得将值设为 false，或者删除 draft，不然会被认定为草稿只能本地运行而不能运行到网站上。 Hogo方式搭建博客基本就是安装，建站，下载主题，配置主题参数，编写几大内容。 使用 GitHub Pages + GitHub Actions 方式部署博客可以节省传统的构建部署繁琐步骤，简化搭建博客的过程，让个人博客爱好者更能专注于自身博客的内部撰写，而不用拘泥于博客整体的维护过程，提高效率 ","date":"2021-11-06","objectID":"/blog-setup/:5:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"5. 参考 https://huweicai.com/ https://www.pseudoyu.com/zh/2022/05/29/deploy_your_blog_using_hugo_and_github_action/ https://cuttontail.blog/blog/create-a-wesite-using-github-pages-and-hugo/ https://blog.csdn.net/wolanx/article/details/122857729?spm=1001.2014.3001.5502 https://cloud.tencent.com/developer/article/1421879 https://h1z3y3.me/posts/hugo-auto-deploy-github-with-actions/ ","date":"2021-11-06","objectID":"/blog-setup/:6:0","tags":["blog"],"title":"Blog 搭建之路","uri":"/blog-setup/"},{"categories":null,"content":"Mazikai","date":"2021-09-02","objectID":"/about/","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":" ~ Not Day But Today ~ 2020年拍摄于宜昌拍摄于宜昌 \" 2020年拍摄于宜昌 ","date":"2021-09-02","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"个人简介 Hello , My name is Mazikai . Major in Observability . If you have any questions or idea, Communications are welcome! Please Mail ","date":"2021-09-02","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"个人经历 贝壳找房科技有限公司 平台研发组 2021.07~至今 华中科技大学.硕士 材料加工工程 2018.07~2021.06 武汉科技大学.学士 材料成型及控制工程 2014.07~2018.06 ","date":"2021-09-02","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"专业技能 计算机基础 : 掌握操作系统、计算机网络、数据结构与算法；了解计算机组成原理 编程语言 : 掌握 Go 语言(调度模型、内存管理、并发编程)、Shell 脚本；了解 Java 语言 语言框架 : 掌握 Gin 、GORM 等主流框架 数据库 : 掌握 MySQL 数据库及常见优化手段(索引、SQL 优化、读写分离、分库分表)、Redis 数据库(缓存、分布式锁) 分布式 : 掌握 Prometheus 指标监控、Consul 服务网络；了解 SkyWalking 链路追踪、Kafka 消息队列、Elasticsearch 搜索引擎、ELK 日志检索、OpenTelemetry 可观测性框架 云原生 : 了解 Kubernetes 容器编排工具、APISIX 云网关 其他 : 掌握 Linux 及常用命令(有开发部署项目经验)、 Git、Docker、Markdown ","date":"2021-09-02","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"}]