[{"categories":["Go"],"content":"make和new是内置函数，不是关键字，var是关键字","date":"2021-12-06","objectID":"/categories/go/go_new_make/","tags":["Go"],"title":"Go 基本语法 —— var、new、make区别及使用","uri":"/categories/go/go_new_make/"},{"categories":["Go"],"content":" make和new是内置函数，不是关键字，var是关键字 一：对于值类型的变量，我们通过var 声明(包括结构体)，系统会默认为他分配内存空间，并赋该类型的零值。如下，我们声明一个int类型变量i，输出为0。 var i int fmt.Println(i) //i=0 而如果我们声明一个指针类型的变量，系统不会为他分配内存(应该是不会为这个指针分配一个内存给他指向)，默认就是nil。此时如果你想直接使用，那么系统会抛异常。 var j *int fmt.Println(j) //nil类型，因为指针的0值就是nil fmt.Println(\u0026j) //0xc00000e028 这是指针变量的地址 fmt.Println(*j) //因为这个指针没有指向任何内存,报错 *j = 10 //invalid memory address or nil pointer dereference， 空指针还没指向任何内存，是不能使用的。 二：那么要想使用，此时就需要new出场啦。 var j *int j = new(int) // j里面的内容指向一块分配好的内存地址，地址里面设置int的零值：0 fmt.Println(j) // 0xc000018040 fmt.Println(*j) //0 *j = 10 fmt.Println(*j) 声明指针类型变量后，通过new为他分配指向的内存，有了内存空间，这个变量就可以自由的使用了。 来看一下new函数的签名： 它只接受一个参数，这个参数是一个类型，**分配好内存后，返回一个指向该类型内存地址的指针。这块内存上存的是类型的零值。**这个类型也能是指针。 package main import ( \"fmt\" ) func main(){ a := new(*int) fmt.Println(a) fmt.Println(*a) *a = new(int) fmt.Println(*a) fmt.Println(**a) } 0xc0000b2018 \u003cnil\u003e 0xc0000b8010 0 *但是，**实际在工程使用中，通常是直接声明指针使用，不需要new操作。 三：make和new不同，make用于map, slice,chan 的内存创建，因为他们三个是引用类型，直接返回这三个类型本身。make签名是： func make(t Type, size ...IntegerType) Type make 是分配内存并初始化，初始化并不是置为零值。 与new一样，它的第一个参数也是一个类型，但是不一样的是，make返回的是传入的类型，而不是指针！ var c chan int //声明管道类型变量c，此时c还是nil，不可用； fmt.Printf(\"%#v \\\\n\",c) //(chan int)(nil) c = make(chan int) fmt.Printf(\"%#v\", c) //(chan int)(0xc000062060) 声明管道类型变量c，此时c还是nil，不可用； 通过make来分配内存并初始化，c就获得了内存可以使用了。 所以，我们在使用map, slice,chan 的时候，需要先对他们用make初始化，然后在进行操作。 总结： var 分配内存，赋0值，返回类型 new 分配内存，赋0值，返回类型指针（指向刚才分配内存的指针） make给map，channel，slice分配内存，不赋0值，返回类型 Var指针类型一般是var+new；Var三种引用类型时候，一般是var+make make和new的区别 new 和 make都是用来创建和分配内存的，可能在栈上，也可能在堆上，是内存逃逸分析后确定创建在哪里的。 new 返回的是指针，指向新分配的类型的零值；make 返回的是值，这个值已经被初始化（例如，一个新的切片，它的元素已经被分配了内存）。 new 可以用于任何类型，而 make 只能用于切片、映射和通道。 make 创建的切片、映射或通道已经准备好使用，而 new 创建的值需要进一步初始化。 为什么要给三种引用类型单独实现一个make 函数？ 这是因为slice, map和chan的底层结构上要求在使用slice，map和chan的时候必须初始化，如果不初始化，那slice，map和chan的值就是零值，也就是nil。我们知道： map如果是nil，是不能往map插入元素的，插入元素会引发panic chan如果是nil，往chan发送数据或者从chan接收数据都会阻塞 slice会有点特殊，理论上slice如果是nil，也是没法用的。但是append函数处理了nil slice的情况，可以调用append函数对nil slice做扩容。但是我们使用slice，总是会希望可以自定义长度或者容量，这个时候就需要用到make。 那么，可以使用new来初始化引用类型吗？可以的！ 参考 https://huweicai.com/ https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/ https://blog.wu-boy.com/2021/06/what-is-different-between-new-and-make-in-golang/ https://fivezh.github.io/2020/03/15/golang-new-make/ ","date":"2021-12-06","objectID":"/categories/go/go_new_make/:0:0","tags":["Go"],"title":"Go 基本语法 —— var、new、make区别及使用","uri":"/categories/go/go_new_make/"},{"categories":["Go"],"content":"make和new是内置函数，不是关键字，var是关键字","date":"2021-12-06","objectID":"/go_new_make/","tags":["Go"],"title":"Go 基本语法 —— var、new、make区别及使用","uri":"/go_new_make/"},{"categories":["Go"],"content":" make和new是内置函数，不是关键字，var是关键字 一：对于值类型的变量，我们通过var 声明(包括结构体)，系统会默认为他分配内存空间，并赋该类型的零值。如下，我们声明一个int类型变量i，输出为0。 var i int fmt.Println(i) //i=0 而如果我们声明一个指针类型的变量，系统不会为他分配内存(应该是不会为这个指针分配一个内存给他指向)，默认就是nil。此时如果你想直接使用，那么系统会抛异常。 var j *int fmt.Println(j) //nil类型，因为指针的0值就是nil fmt.Println(\u0026j) //0xc00000e028 这是指针变量的地址 fmt.Println(*j) //因为这个指针没有指向任何内存,报错 *j = 10 //invalid memory address or nil pointer dereference， 空指针还没指向任何内存，是不能使用的。 二：那么要想使用，此时就需要new出场啦。 var j *int j = new(int) // j里面的内容指向一块分配好的内存地址，地址里面设置int的零值：0 fmt.Println(j) // 0xc000018040 fmt.Println(*j) //0 *j = 10 fmt.Println(*j) 声明指针类型变量后，通过new为他分配指向的内存，有了内存空间，这个变量就可以自由的使用了。 来看一下new函数的签名： 它只接受一个参数，这个参数是一个类型，**分配好内存后，返回一个指向该类型内存地址的指针。这块内存上存的是类型的零值。**这个类型也能是指针。 package main import ( \"fmt\" ) func main(){ a := new(*int) fmt.Println(a) fmt.Println(*a) *a = new(int) fmt.Println(*a) fmt.Println(**a) } 0xc0000b2018 \u003cnil\u003e 0xc0000b8010 0 *但是，**实际在工程使用中，通常是直接声明指针使用，不需要new操作。 三：make和new不同，make用于map, slice,chan 的内存创建，因为他们三个是引用类型，直接返回这三个类型本身。make签名是： func make(t Type, size ...IntegerType) Type make 是分配内存并初始化，初始化并不是置为零值。 与new一样，它的第一个参数也是一个类型，但是不一样的是，make返回的是传入的类型，而不是指针！ var c chan int //声明管道类型变量c，此时c还是nil，不可用； fmt.Printf(\"%#v \\\\n\",c) //(chan int)(nil) c = make(chan int) fmt.Printf(\"%#v\", c) //(chan int)(0xc000062060) 声明管道类型变量c，此时c还是nil，不可用； 通过make来分配内存并初始化，c就获得了内存可以使用了。 所以，我们在使用map, slice,chan 的时候，需要先对他们用make初始化，然后在进行操作。 总结： var 分配内存，赋0值，返回类型 new 分配内存，赋0值，返回类型指针（指向刚才分配内存的指针） make给map，channel，slice分配内存，不赋0值，返回类型 Var指针类型一般是var+new；Var三种引用类型时候，一般是var+make make和new的区别 new 和 make都是用来创建和分配内存的，可能在栈上，也可能在堆上，是内存逃逸分析后确定创建在哪里的。 new 返回的是指针，指向新分配的类型的零值；make 返回的是值，这个值已经被初始化（例如，一个新的切片，它的元素已经被分配了内存）。 new 可以用于任何类型，而 make 只能用于切片、映射和通道。 make 创建的切片、映射或通道已经准备好使用，而 new 创建的值需要进一步初始化。 为什么要给三种引用类型单独实现一个make 函数？ 这是因为slice, map和chan的底层结构上要求在使用slice，map和chan的时候必须初始化，如果不初始化，那slice，map和chan的值就是零值，也就是nil。我们知道： map如果是nil，是不能往map插入元素的，插入元素会引发panic chan如果是nil，往chan发送数据或者从chan接收数据都会阻塞 slice会有点特殊，理论上slice如果是nil，也是没法用的。但是append函数处理了nil slice的情况，可以调用append函数对nil slice做扩容。但是我们使用slice，总是会希望可以自定义长度或者容量，这个时候就需要用到make。 那么，可以使用new来初始化引用类型吗？可以的！ 参考 https://huweicai.com/ https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/ https://blog.wu-boy.com/2021/06/what-is-different-between-new-and-make-in-golang/ https://fivezh.github.io/2020/03/15/golang-new-make/ ","date":"2021-12-06","objectID":"/go_new_make/:0:0","tags":["Go"],"title":"Go 基本语法 —— var、new、make区别及使用","uri":"/go_new_make/"},{"categories":["Go"],"content":"make和new是内置函数，不是关键字，var是关键字","date":"2021-12-06","objectID":"/tags/go/go_new_make/","tags":["Go"],"title":"Go 基本语法 —— var、new、make区别及使用","uri":"/tags/go/go_new_make/"},{"categories":["Go"],"content":" make和new是内置函数，不是关键字，var是关键字 一：对于值类型的变量，我们通过var 声明(包括结构体)，系统会默认为他分配内存空间，并赋该类型的零值。如下，我们声明一个int类型变量i，输出为0。 var i int fmt.Println(i) //i=0 而如果我们声明一个指针类型的变量，系统不会为他分配内存(应该是不会为这个指针分配一个内存给他指向)，默认就是nil。此时如果你想直接使用，那么系统会抛异常。 var j *int fmt.Println(j) //nil类型，因为指针的0值就是nil fmt.Println(\u0026j) //0xc00000e028 这是指针变量的地址 fmt.Println(*j) //因为这个指针没有指向任何内存,报错 *j = 10 //invalid memory address or nil pointer dereference， 空指针还没指向任何内存，是不能使用的。 二：那么要想使用，此时就需要new出场啦。 var j *int j = new(int) // j里面的内容指向一块分配好的内存地址，地址里面设置int的零值：0 fmt.Println(j) // 0xc000018040 fmt.Println(*j) //0 *j = 10 fmt.Println(*j) 声明指针类型变量后，通过new为他分配指向的内存，有了内存空间，这个变量就可以自由的使用了。 来看一下new函数的签名： 它只接受一个参数，这个参数是一个类型，**分配好内存后，返回一个指向该类型内存地址的指针。这块内存上存的是类型的零值。**这个类型也能是指针。 package main import ( \"fmt\" ) func main(){ a := new(*int) fmt.Println(a) fmt.Println(*a) *a = new(int) fmt.Println(*a) fmt.Println(**a) } 0xc0000b2018 \u003cnil\u003e 0xc0000b8010 0 *但是，**实际在工程使用中，通常是直接声明指针使用，不需要new操作。 三：make和new不同，make用于map, slice,chan 的内存创建，因为他们三个是引用类型，直接返回这三个类型本身。make签名是： func make(t Type, size ...IntegerType) Type make 是分配内存并初始化，初始化并不是置为零值。 与new一样，它的第一个参数也是一个类型，但是不一样的是，make返回的是传入的类型，而不是指针！ var c chan int //声明管道类型变量c，此时c还是nil，不可用； fmt.Printf(\"%#v \\\\n\",c) //(chan int)(nil) c = make(chan int) fmt.Printf(\"%#v\", c) //(chan int)(0xc000062060) 声明管道类型变量c，此时c还是nil，不可用； 通过make来分配内存并初始化，c就获得了内存可以使用了。 所以，我们在使用map, slice,chan 的时候，需要先对他们用make初始化，然后在进行操作。 总结： var 分配内存，赋0值，返回类型 new 分配内存，赋0值，返回类型指针（指向刚才分配内存的指针） make给map，channel，slice分配内存，不赋0值，返回类型 Var指针类型一般是var+new；Var三种引用类型时候，一般是var+make make和new的区别 new 和 make都是用来创建和分配内存的，可能在栈上，也可能在堆上，是内存逃逸分析后确定创建在哪里的。 new 返回的是指针，指向新分配的类型的零值；make 返回的是值，这个值已经被初始化（例如，一个新的切片，它的元素已经被分配了内存）。 new 可以用于任何类型，而 make 只能用于切片、映射和通道。 make 创建的切片、映射或通道已经准备好使用，而 new 创建的值需要进一步初始化。 为什么要给三种引用类型单独实现一个make 函数？ 这是因为slice, map和chan的底层结构上要求在使用slice，map和chan的时候必须初始化，如果不初始化，那slice，map和chan的值就是零值，也就是nil。我们知道： map如果是nil，是不能往map插入元素的，插入元素会引发panic chan如果是nil，往chan发送数据或者从chan接收数据都会阻塞 slice会有点特殊，理论上slice如果是nil，也是没法用的。但是append函数处理了nil slice的情况，可以调用append函数对nil slice做扩容。但是我们使用slice，总是会希望可以自定义长度或者容量，这个时候就需要用到make。 那么，可以使用new来初始化引用类型吗？可以的！ 参考 https://huweicai.com/ https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/ https://blog.wu-boy.com/2021/06/what-is-different-between-new-and-make-in-golang/ https://fivezh.github.io/2020/03/15/golang-new-make/ ","date":"2021-12-06","objectID":"/tags/go/go_new_make/:0:0","tags":["Go"],"title":"Go 基本语法 —— var、new、make区别及使用","uri":"/tags/go/go_new_make/"},{"categories":["documentation"],"content":"博客的意义在于自己梳理知识，总结经验，顺便和他人进行技术交流","date":"2021-11-06","objectID":"/first_blog/","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":" 博客的意义在于自己梳理知识，总结经验，顺便和他人进行技术交流。 这是我的第一篇博客，记录我是如何搭建这个网站的！希望对您也有帮助~ ","date":"2021-11-06","objectID":"/first_blog/:0:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"所需工具 ","date":"2021-11-06","objectID":"/first_blog/:1:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"Hugo + GitHub Pages + GitHub Actions + DomainRegistration ","date":"2021-11-06","objectID":"/first_blog/:1:1","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"1 概念 ","date":"2021-11-06","objectID":"/first_blog/:2:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"1.1 什么是 Hugo？ Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator）。可以把 Markdown 文件转化成 HTML 文件。 ","date":"2021-11-06","objectID":"/first_blog/:2:1","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"1.2 什么是 GitHub Pages？ GitHub Pages 是一组静态网页集合（Static Web Page），这些静态网页 HTML 文件由 GitHub 托管（host）和发布，所以是 GitHub + Pages。 ","date":"2021-11-06","objectID":"/first_blog/:2:2","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"1.3 Github Action Hugo 都是静态博客，即最终生成的是静态页面，而所谓部署就是把这些静态文件放到 web 服务器(比如 Nginx、Caddy) 的对应目录就行了。 因此整个 Github Action 只需要做两件事： 1）编译，生成静态文件 2）部署，把静态文件移动到合适的位置 - 比如放到某个云服务器上 - 或者放到 Github Pages 然后我们再通过 git push 来触发 Github Action 就可以了。 ","date":"2021-11-06","objectID":"/first_blog/:2:3","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"2 过程 ","date":"2021-11-06","objectID":"/first_blog/:3:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"2.1 配置Hugo 2.1.1 安装Hugo 这里使用包管理器安装 Hugo，我的操作系统是 Mac OS，所以使用 Homebrew 安装 Hugo。如果你使用的是 Windows 或 Linux，可以根据 Hugo 文档提示的方式安装： Hugo 文档：Install Hugo brew install hugo # 查看 Hugo 是否安装成功，显示 Hugo 版本号代表 Hugo 安装成功。 hugo version 2.1.2 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了。 hugo new site Blog 2.1.3 配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。下面我就以我目前在使用的 LoveIt 这个主题为例，演示一下配置流程。 我们可以将主题仓库直接 git clone 下来进行使用，但这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。我采用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。 cd blog-test/ git init git submodule add https://github.com/pseudoyu/LoveIt themes/LoveIt 每个主题一般都会提供一些实例配置与初始页面，开始使用主题时可以将其 exampleSite/ 目录下的文件复制到站点目录下，在此基础上进行调整配置。 cp -rf themes/LoveIt/exampleSite/* ./ 初始化主题基础配置后，我们可以在 config.toml 文件中进行站点细节配置，具体配置项参考各主题说明文档。 2.1.4 发布文章 完成后，可以通过 hugo new 命令发布新文章。 hugo new posts/blog-test.md 2.1.5 本地调试 Hugo 会生成静态网页，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。 hugo server 运行服务后，我们可以通过浏览器 http://localhost:1313 地址访问我们的本地预览网页。 ","date":"2021-11-06","objectID":"/first_blog/:3:1","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"2.2 创建GitHub仓库 命名博客源仓库（username.github.io） 勾选 Public，设置为公开仓库。 勾选添加 README 文件 ","date":"2021-11-06","objectID":"/first_blog/:3:2","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"2.3 创建GitHub Page 在博客源仓库下创建GitHub Pages（Settings-\u003ePages） ","date":"2021-11-06","objectID":"/first_blog/:3:3","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"2.4 创建GitHub Actions 需要在仓库根目录下创建 .github/workflows 这个二级目录，然后在 workflows 下以 .yml 形式配置 Github Action。 name:publish to gh-pages# 流水线名称on:# on 表示 GitHub Action 触发条件push:branches:- main# main分支env:REGISTRY:ghcr.ioIMAGE_NAME:${{ github.repository }}jobs:# jobs 表示 GitHub Action 中的任务build:runs-on:ubuntu-latest# runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。# permissions:# contents: read# packages: writeconcurrency:group:${{ github.workflow }}-${{ github.ref }}steps:- name:checkout# 检查uses:actions/checkout@v2# uses 中的为 GitHub Action 中的一个插件with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:setup hugo# 安装uses:peaceiris/actions-hugo@v2 with:hugo-version:'0.105.0'# hugo的版本号extended:true- name:build web# 构建run:hugo --minify- name:deploy web# 部署uses:peaceiris/actions-gh-pages@v3if:${{ github.ref == 'refs/heads/main' }}with:github_token:${{ secrets.GH_PAGE_ACTION_TOKEN }}publish_dir:./publiccname:mazikai002.cn# 重点 ！！！个人域名使用# PUBLISH_BRANCH: gh-pages，peaceiris/actions-gh-pages@v3插件默认指定生成分支 整个 Action 一个包含 4 个步骤： 1）拉取代码 2）准备 hugo 环境 3）使用 hugo 编译生成静态文件 4）把生成的静态文件发布到 Github Pages 以上需要特别注意的是 Hugo 的版本以及是否启用 hugo 扩展。 因为我们需要从仓库的main分支推送到仓库的gh-pages分支，这需要特定权限，故要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。 权限需要开启admin:org(read write)、repo、workflow三块权限。 配置后复制生成的 Token（注：只会出现一次），然后在我们博客源仓库的 Settings - Secrets and variables - Actions - Environment secrets 中添加 GITHUB_TOKEN 环境变量为刚才的 Token，这样 GitHub Action 就可以获取到 Token 了。 同时 Settings - Actions - General的最下方的一个选项选择Read and write permissions 完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。 ","date":"2021-11-06","objectID":"/first_blog/:3:4","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"2.5 博客绑定域名 2.5.1 创建 CNAME 首先在你的库下面添加一个 CNAME （别名记录）文件，建议直接在 GitHub 那创建!(这一步在workflows的yml文件中最后一行已经配置)，参考你的域名进行编写。 2.5.2 添加 DNS 解析 然后是添加解析，我域名是在腾讯云买的，所以直接在腾讯云那添加解析了。 我添加的解析如下,供参考，记得把 username 改成你自己的。 @ A 185.199.109.153 @ A 185.199.110.153 www CNAME username.github.io. A 记录的 ip 地址可以在下面中选择 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 2.5.3 修改设置 添加完成后进入库的设置，找到 GitHub Pages ，如果能看到类似 Your site is published at https://mazikai002.cn/ 这样的文字，说明就搞定了。 Enforce HTTPS 最好勾选上，GitHub 提供的这个可以直接让你的网站从 HTTP 升级到 HTTPS，非常赞。 ","date":"2021-11-06","objectID":"/first_blog/:3:5","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"3 流程 使用hugo创建个人站点，hugo new site，hugo new post… git commit 提交 触发 github action .github/workflows/my-pipeline.yml 并满足设置中的 on 条件 触发 pipeline 中的 steps checkout：相当与 git clone，并且后续操作具有 github 完整权限，可以通过 permissions 设置 setup hugo：准备构建要求，安装对应版本，注意是否需要 extended build：构建出静态文件，并输出到 public 文件夹 deploy：该插件来自 插件市场 自动创建分支 gh-pages 自动 copy public 到新分支 自动提交 自动生成 CNAME 文件，根据 cname 设置，想要 自定义域名 的注意这里了 打开 https://github.com/{你的名字}/{你的仓库}/settings/pages（后续步骤只需要一次） Source 选择 gh-pages ，文件夹: 默认 / (root) ，并 save 注意上方提示 Your site is ready to be published at https://xxx.github.io/xxx/ 将域名部分做 解析 Custom domain 设置 自己的域名 Enforce HTTPS 点一下，然后等一会 ","date":"2021-11-06","objectID":"/first_blog/:4:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"4 总结 可以将主题下相关文件复制到 blog 网站根目录下，因为这样可以直接渲染网站效果，而又不影响主题本身的内容。 主要是 themes\\LoveIt\\exampleSite 目录下文件。 发布文章如果有参数 draft ，记得将值设为 false，或者删除 draft，不然会被认定为草稿只能本地运行而不能运行到网站上。 Hogo方式搭建博客基本就是安装，建站，下载主题，配置主题参数，编写几大内容。 使用 GitHub Pages + GitHub Actions 方式部署博客可以节省传统的构建部署繁琐步骤，简化搭建博客的过程，让个人博客爱好者更能专注于自身博客的内部撰写，而不用拘泥于博客整体的维护过程，提高效率 ","date":"2021-11-06","objectID":"/first_blog/:5:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":["documentation"],"content":"5. 参考 https://huweicai.com/ https://www.pseudoyu.com/zh/2022/05/29/deploy_your_blog_using_hugo_and_github_action/ https://cuttontail.blog/blog/create-a-wesite-using-github-pages-and-hugo/ https://blog.csdn.net/wolanx/article/details/122857729?spm=1001.2014.3001.5502 https://cloud.tencent.com/developer/article/1421879 https://h1z3y3.me/posts/hugo-auto-deploy-github-with-actions/ ","date":"2021-11-06","objectID":"/first_blog/:6:0","tags":["installation","configuration"],"title":"Blog 搭建之路","uri":"/first_blog/"},{"categories":null,"content":"Mazikai","date":"2021-09-02","objectID":"/about/","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":" \" Not Day But Today \" 2020年拍摄于宜昌拍摄于宜昌 \" 2020年拍摄于宜昌 ","date":"2021-09-02","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"个人简介 Hello , My name is Mazikai . Major in Observability . If you have any questions or idea, Communications are welcome! Please Mail ","date":"2021-09-02","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"个人经历 贝壳找房科技有限公司 平台研发组 2021.07~至今 华中科技大学.硕士 材料加工工程 2018.07~2021.06 武汉科技大学.学士 材料成 型及控制工程 2014.07~2018.06 ","date":"2021-09-02","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"专业技能 计算机基础 : 掌握操作系统、计算机网络、数据结构与算法；了解计算机组成原理 编程语言 : 掌握 Go 语言(调度模型、内存管理、并发编程)、Shell 脚本；了解 Java 语言 语言框架 : 掌握 Gin 、GORM 等主流框架 数据库 : 掌握 MySQL 数据库及常见优化手段(索引、SQL 优化、读写分离、分库分表)、Redis 数据库(缓存、分布式锁) 分布式 : 掌握 Prometheus 指标监控、Consul 服务网络；了解 SkyWalking 链路追踪、Kafka 消息队列、Elasticsearch 搜索引擎、ELK 日志检索、OpenTelemetry 可观测性框架 云原生 : 了解 Kubernetes 容器编排工具、APISIX 云网关 其他 : 掌握 Linux 及常用命令(有开发部署项目经验)、 Git、Docker、Markdown ","date":"2021-09-02","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"}]