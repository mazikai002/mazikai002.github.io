<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - Mazikai's Blog</title><link>https://mazikai002.github.io/posts/</link><description>所有文章 | Mazikai's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>mazikai002@gmail.com (mazikai002)</managingEditor><webMaster>mazikai002@gmail.com (mazikai002)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 15 Mar 2024 11:27:33 +0800</lastBuildDate><atom:link href="https://mazikai002.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>算法刷题 —— 判断图中是否有环(Leetcode 207)</title><link>https://mazikai002.github.io/code_graph_without_ring/</link><pubDate>Fri, 15 Mar 2024 11:27:33 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code_graph_without_ring/</guid><description>判断图中是否有环 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main func main() { } type Graph struct { grips []grip } type grip struct { inDegree int pointTo []grip</description></item><item><title>算法刷题 —— 最长递增子序列(Leetcode 300)</title><link>https://mazikai002.github.io/code_the_longest_increasing_subsequence/</link><pubDate>Wed, 13 Mar 2024 16:50:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code_the_longest_increasing_subsequence/</guid><description>最长递增子序列 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main func main() { } // O(n2) func lengthOfLIS(nums []int) int { res := math.MinInt dp := make([]int,len(nums)) for i := 0 ; i &amp;lt; len(nums) ; i++ { dp[i] = 1 } for i :=</description></item><item><title>Prometheus 原理分析 —— 深入TSDB存储</title><link>https://mazikai002.github.io/prometheus_tsdb/</link><pubDate>Sat, 02 Mar 2024 11:33:42 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/prometheus_tsdb/</guid><description><![CDATA[<blockquote>
<p>聊聊 Prometheus 的时序数据库 TSDB ~</br></p>
</blockquote>]]></description></item><item><title>Golang 性能提升 —— sync.Pool</title><link>https://mazikai002.github.io/go-sync_pool/</link><pubDate>Tue, 06 Feb 2024 19:51:20 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/go-sync_pool/</guid><description><![CDATA[<blockquote>
<p>一句话总结 : 保存和复用临时对象，减少内存分配，降低 GC 压力。</br></p>
</blockquote>]]></description></item><item><title>计算机网络 —— TCP报文类型</title><link>https://mazikai002.github.io/network-tcp_type/</link><pubDate>Sun, 28 Jan 2024 14:26:16 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/network-tcp_type/</guid><description><![CDATA[<blockquote>
<p>很多人可能知道TCP报文格式，但当提及报文类型时却一问三不知。 </br>
本文梳理了TCP报文类型，希望对您有帮助 ~ </br></p>
</blockquote>]]></description></item><item><title>分布式系统 —— 容灾架构</title><link>https://mazikai002.github.io/distributed/</link><pubDate>Tue, 02 Jan 2024 12:22:53 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/distributed/</guid><description><![CDATA[<blockquote>
<p>后台服务可以分为两类 : 有状态和无状态。</br>
容灾架构对无状态的服务(计算型服务)很简单，不外乎就是多加相同实例；但对有状态服务(存储型服务)就不是那么轻松。</br>
下文为作者梳理的容灾架构相关内容，希望对您有帮助 ~ </br></p>
</blockquote>]]></description></item><item><title>Golang 底层原理 —— 逃逸分析</title><link>https://mazikai002.github.io/go-escape_analyze/</link><pubDate>Mon, 25 Dec 2023 19:51:23 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/go-escape_analyze/</guid><description><![CDATA[<blockquote>
<p>逃逸分析 —— 让Golang程序员专注高效工作的挖井人！</br></p>
</blockquote>]]></description></item><item><title>Redis 高可用 —— 主从、哨兵、集群</title><link>https://mazikai002.github.io/redis-high_availability/</link><pubDate>Thu, 16 Nov 2023 20:14:52 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/redis-high_availability/</guid><description><![CDATA[<blockquote>
<p>所谓的高可用，也叫 HA（High Availability），是分布式系统架构设计中必须考虑的因素之一，它通常指，通过设计减少系统不能提供服务的时间。 </br>
本文梳理了Redis高可用的三种模式(主从、哨兵、集群)。希望对您有帮助 ~  </br></p>
</blockquote>]]></description></item><item><title>Golang 底层原理 —— 内存管理</title><link>https://mazikai002.github.io/go-memory_manage/</link><pubDate>Thu, 05 Oct 2023 17:32:13 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/go-memory_manage/</guid><description><![CDATA[<blockquote>
<p>作者当前认知的Golang内存管理机制</br></p>
</blockquote>]]></description></item><item><title>Redis 缓存异常 —— 缓存雪崩、击穿、穿透</title><link>https://mazikai002.github.io/redis-cache_exception/</link><pubDate>Fri, 08 Sep 2023 22:03:13 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/redis-cache_exception/</guid><description><![CDATA[<blockquote>
<p>引入缓存层，会有缓存异常的三个常见问题，分别是缓存雪崩、击穿、穿透。 </br>
本文总结了这三个问题的定义、原因以及应对方案。 </br>
请看如下表格，希望对您有帮助 ~  </br></p>
</blockquote>]]></description></item></channel></rss>