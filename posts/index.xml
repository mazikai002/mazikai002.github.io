<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - Mazikai's Blog</title><link>https://mazikai002.github.io/posts/</link><description>所有文章 | Mazikai's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>mazikai002@gmail.com (mazikai002)</managingEditor><webMaster>mazikai002@gmail.com (mazikai002)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 29 Jul 2024 23:19:42 +0800</lastBuildDate><atom:link href="https://mazikai002.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Kafka 系列</title><link>https://mazikai002.github.io/kafka_foundation/</link><pubDate>Mon, 29 Jul 2024 23:19:42 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/kafka_foundation/</guid><description><![CDATA[<blockquote>
<p>为什么选择Kafka? </br></p>
</blockquote>]]></description></item><item><title>算法刷题 —— 快速排序</title><link>https://mazikai002.github.io/code-kth_largest_element_in_array/</link><pubDate>Mon, 25 Mar 2024 14:50:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-kth_largest_element_in_array/</guid><description>快速排序 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func main() { res := []int{4, 1, 2, 3, 7} res := quickSort(res) fmt.Println(res) } func quickSort(nums []int, left, right int) { if left &amp;gt;= right { // 下标重叠不用排序</description></item><item><title>算法刷题 —— 数组中的第K个最大元素</title><link>https://mazikai002.github.io/code-quicksort/</link><pubDate>Fri, 22 Mar 2024 14:50:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-quicksort/</guid><description>数组中的第K个最大元素 —— 堆排序 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func main() { res := []int{4, 1, 2, 3, 7} res := quickSort(res) fmt.Println(res)</description></item><item><title>算法刷题 —— 交替打印</title><link>https://mazikai002.github.io/code-alternate_printing/</link><pubDate>Wed, 20 Mar 2024 20:50:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-alternate_printing/</guid><description>使用两个Goroutine，向标准输出中按顺序按顺序交替打出字母与数字，输出是a1b2c3&amp;hellip;z26 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13</description></item><item><title>算法刷题 —— 最小覆盖子串(Leetcode 76)</title><link>https://mazikai002.github.io/code-minimum_covering_substring/</link><pubDate>Wed, 20 Mar 2024 20:40:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-minimum_covering_substring/</guid><description>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;quot;&amp;quot; ~ 1 2 3 4 5 6 7 8 9 10</description></item><item><title>算法刷题 —— 判断图中是否有环(Leetcode 207)</title><link>https://mazikai002.github.io/code-graph_without_ring/</link><pubDate>Fri, 15 Mar 2024 11:27:33 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-graph_without_ring/</guid><description>判断图中是否有环 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main func main() { } type Graph struct { grips []grip } type grip struct { inDegree int pointTo []grip</description></item><item><title>算法刷题 —— 最长递增子序列(Leetcode 300)</title><link>https://mazikai002.github.io/code-the_longest_increasing_subsequence/</link><pubDate>Wed, 13 Mar 2024 16:50:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-the_longest_increasing_subsequence/</guid><description>最长递增子序列 ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main func main() { } // O(n2) func lengthOfLIS(nums []int) int { res := math.MinInt dp := make([]int,len(nums)) for i := 0 ; i &amp;lt; len(nums) ; i++ { dp[i] = 1 } for i :=</description></item><item><title>Prometheus 原理分析 —— 深入TSDB存储</title><link>https://mazikai002.github.io/prometheus_tsdb/</link><pubDate>Sat, 02 Mar 2024 11:33:42 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/prometheus_tsdb/</guid><description><![CDATA[<blockquote>
<p>聊聊 Prometheus 的时序数据库 TSDB ~</br></p>
</blockquote>]]></description></item><item><title>Golang 性能提升 —— sync.Pool</title><link>https://mazikai002.github.io/go-sync_pool/</link><pubDate>Tue, 06 Feb 2024 19:51:20 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/go-sync_pool/</guid><description><![CDATA[<blockquote>
<p>一句话总结 : 保存和复用临时对象，减少内存分配，降低 GC 压力。</br></p>
</blockquote>]]></description></item><item><title>算法刷题 —— 判断 nums 中是否存在某个子序列之和等于 k</title><link>https://mazikai002.github.io/code-sum_judged_be_k/</link><pubDate>Tue, 06 Feb 2024 19:50:00 +0800</pubDate><author>mazikai</author><guid>https://mazikai002.github.io/code-sum_judged_be_k/</guid><description>判断 nums 中是否存在某个子序列之和等于 k ~ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { a := []int{4, 1, 2, 4, 7} res := IsContainNumTotalK(a, 20) fmt.Println(res) } func IsContainNumTotalK(nums []int, k int) bool { if k == 0 { return true } else</description></item></channel></rss>